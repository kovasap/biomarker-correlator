{"version":3,"sources":["app/specs.cljs"],"mappings":";AAQA,AAAKA,uBACH,wDAAA,iFAAA,mFAAA,2CAAA,vQAACC,6TACSC;AACZ,AAAAC,yBAAA,AAAA,iFAAA,AAAA,sFAAoBH;AAGpB,AAAKI,+BACH,wDAAA,kGAAA,2CAAA,+EAAA,yEAAA,7VAACH,6PACSI,yEACFA,yFACOC;AACjB,AAAAH,yBAAA,AAAA,kGAAA,AAAA,sGAA4BC;AAG5B,AAAKG,kCACH,wDAAA,uGAAA,mFAAA,2CAAA,+EAAA,yFAAA,gFAAA,rhBAACN,mVACUC,yFACIA;AAEjB,AAAAC,yBAAA,AAAA,uGAAA,AAAA,4GAA+BI;AAG/B,AAAKC,oCACH,wDAAA,4GAAA,2CAAA,kFAAA,6EAAA,kFAAA,oEAAA,mFAAA,2CAAA,sFAAA,gFAAA,xyBAACP,wQACWC,iFACFI,gFACED,sRACiBH;AAE/B,AAAAC,yBAAA,AAAA,4GAAA,AAAA,+GAAiCK;AACjC,AAAAL,yBAAA,AAAA,8GAAA,AAAA,wNACE,AAAAM,yDAAA,AAAA,4GAAA,4GAAA,2CAAA,6FAAA,AAAA,KAAA,oFAAA,WAAAC;AAAA,AAAA,OAAAC,sBAAAD;GAAA,8FAAA,KAAA,0FAAA,AAAA,gOAAA;AAGF,AAAAP,yBAAA,AAAA,yEAAA,AAAA,iFAAgBS","names":["app.specs/dated-rows","spec_tools.data_spec.spec","cljs.core/keyword?","cljs.spec.alpha/def-impl","app.specs/regression-results","cljs.core/float?","cljs.core/int?","app.specs/pairwise-correlations","app.specs/one-to-many-correlation","cljs.spec.alpha.every_impl","G__37532","cljs.core/coll?","cljs.core/vector?"],"sourcesContent":["(ns app.specs\n  (:require\n   [spec-tools.data-spec :as ds]\n   [clojure.test.check.generators]\n   [cljs.spec.gen.alpha :as gen]\n   [cljs.spec.alpha :as s]))\n\n\n(def dated-rows\n  (ds/spec ::dated-rows\n    [{:date keyword?}]))\n(s/def ::dated-rows dated-rows)\n\n\n(def regression-results\n  (ds/spec ::regression-results\n    {:slope float?\n     :rsq float?\n     :datapoints int?}))\n(s/def ::regression-results regression-results)\n\n\n(def pairwise-correlations\n  (ds/spec ::pairwise-correlations\n    [{:input keyword?\n      :biomarker keyword?\n      :regression-results ::regression-results}]))\n(s/def ::pairwise-correlations pairwise-correlations)\n\n\n(def one-to-many-correlation\n  (ds/spec ::one-to-many-correlation\n    {:one-var keyword?\n     :score int?\n     :average float?\n     :correlations [{:many-var keyword?\n                     :regression-results ::regression-results}]}))\n(s/def ::one-to-many-correlation one-to-many-correlation)\n(s/def ::one-to-many-correlations\n  (s/coll-of ::one-to-many-correlation))\n\n\n(s/def ::hiccup vector?)\n\n; (gen/generate (s/gen one-to-many-correlation))\n\n\n\n\n\n; My structure defined using pure spec.\n; (s/def ::input-correlations\n;   (s/keys :req-un [::input ::aggregates ::correlations]))\n; \n; (s/def ::input keyword?)\n; \n; (s/def ::aggregates\n;   (s/keys :req-un [::score ::average]))\n; (s/def ::score int?)\n; (s/def ::average float?)\n; \n; (s/def ::correlations\n;   (s/keys :req-un [::biomarker ::regression-results]))\n; (s/def ::biomarker keyword?)\n; (s/def ::regression-results\n;   (s/coll-of ::regression-result))\n; \n; (s/def ::regression-result\n;   (s/keys :req-un [::slope ::datapoints ::rsq]))\n; (s/def ::slope float?)\n; (s/def ::datapoints int?)\n; (s/def ::rsq float?)\n; \n; (s/valid? ::regression-result {:slope 1.0 :datapoints 2 :rsq 3.4})\n; \n; ; This works as expected!\n; (gen/generate (s/gen ::input-correlations))\n\n; (def dated-row-spec\n;   (ds/spec\n;    {:date string?}))\n\n;; TODO add date validation here\n; (s/def :bc/date (s/and string? #(re-matches #\".* to .*\" %)))\n; \n; (s/def :bc/dated-row (s/keys :req [:bc/date]))\n; \n; (s/def :bc/dated-rows (fn [input] every? #(s/valid? :bc/dated-row %) input))\n\n; This is helpful: https://www.youtube.com/watch?v=5OuOnJXLxVE\n\n; Schema seems like a less verbose, simpler option to start with\n; Or maybe ghostwheel??\n; https://github.com/gnl/ghostwheel\n; This would require doing something like\n; https://github.com/clj-kondo/clj-kondo/blob/master/doc/config.md#lint-a-custom-macro-like-a-built-in-macro\n\n; TODO use https://github.com/binaryage/cljs-devtools\n\n; Documentation\n; https://github.com/metosin/spec-tools/blob/master/docs/02_data_specs.md\n"]}