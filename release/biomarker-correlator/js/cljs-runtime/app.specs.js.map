{"version":3,"sources":["app/specs.cljs"],"mappings":";AAQA,AAAAA,yBAAA,AAAA,sEAAA,AAAA,4pBACE,AAAAC,yDAAA,AAAA,0cAAW,AAAAA,yDAAA,AAAA,meAAA,AAAAG,yDAAA,AAAA,kiBAAA,8uBAAA,2CAAA,qDAAA,mCAAA,6FAAA,AAAA,2EAAA,oFAAA,WAAAC,riCAAUK,yBAAS,AAAAC,6BAAA,mFAAA,0DAAA,iEAAA,AAAA,4PAAA,4IAAA,zDAAeD,yBACDE;AADjC,AAAA,OAAAN,qBAAAD;GAAA,qDAAAC,qBAAA,+EAAA,WAAAC,gBAAAC;AAAA,AAAA,OAAAC,4CAAAD,gBAAA;8vBAAX,2CAAA,6FAAA,AAAA,KAAA,oFAAA,WAAAN,v+BAAW,8FAAA,KAAA,0FAAA,AAAA,wjBAAA;AAAX,AAAA,OAAAC,sBAAAD;GAAA,8FAAA,KAAA,0FAAA,AAAA,oqBAAA;AAGF,AAAAF,yBAAA,AAAA,yEAAA,AAAA,iFAAgBa;AAChB,mBAAA,mFAAA,yDAAA,/JAAKC;AAEL,wBAAA,xBAAMC,wDAEHC;AAFH,AAAA,0FAAA,mDAGQA","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha.every_impl","G__51994","cljs.core/coll?","cljs.spec.alpha.tuple_impl","G__51995","cljs.core/map?","i__9377__auto__","v__9378__auto__","cljs.core.nth","cljs.core/keyword?","cljs.spec.alpha/or-spec-impl","cljs.core/number?","cljs.core/vector?","app.specs/Hiccup","app.specs/make-hiccup","s"],"sourcesContent":["(ns app.specs\n  (:require\n    [spec-tools.data-spec :as ds]\n    [cljs.spec.alpha :as s]\n    [clojure.test.check.generators]\n    [cljs.spec.gen.alpha :as gen]))\n\n\n(s/def ::maps\n  (s/coll-of (s/map-of keyword? (s/or :keyword keyword?\n                                      :number number?))))\n\n(s/def ::hiccup vector?)\n(def Hiccup [:vector :any])\n\n(defn make-hiccup\n  {:malli/schema [:=> [:cat :string] Hiccup]}\n  [s]\n  [:div s])\n  \n\n; (gen/generate (s/gen one-to-many-correlation))\n\n\n; My structure defined using pure spec.\n; (s/def ::input-correlations\n;   (s/keys :req-un [::input ::aggregates ::correlations]))\n; \n; (s/def ::input keyword?)\n; \n; (s/def ::aggregates\n;   (s/keys :req-un [::score ::average]))\n; (s/def ::score int?)\n; (s/def ::average float?)\n; \n; (s/def ::correlations\n;   (s/keys :req-un [::biomarker ::regression-results]))\n; (s/def ::biomarker keyword?)\n; (s/def ::regression-results\n;   (s/coll-of ::regression-result))\n; \n; (s/def ::regression-result\n;   (s/keys :req-un [::slope ::datapoints ::rsq]))\n; (s/def ::slope float?)\n; (s/def ::datapoints int?)\n; (s/def ::rsq float?)\n; \n; (s/valid? ::regression-result {:slope 1.0 :datapoints 2 :rsq 3.4})\n; \n; ; This works as expected!\n; (gen/generate (s/gen ::input-correlations))\n\n; (def dated-row-spec\n;   (ds/spec\n;    {:date string?}))\n\n;; TODO add date validation here\n; (s/def :bc/date (s/and string? #(re-matches #\".* to .*\" %)))\n; \n; (s/def :bc/dated-row (s/keys :req [:bc/date]))\n; \n; (s/def :bc/dated-rows (fn [input] every? #(s/valid? :bc/dated-row %) input))\n\n; This is helpful: https://www.youtube.com/watch?v=5OuOnJXLxVE\n\n; Schema seems like a less verbose, simpler option to start with\n; Or maybe ghostwheel??\n; https://github.com/gnl/ghostwheel\n; This would require doing something like\n; https://github.com/clj-kondo/clj-kondo/blob/master/doc/config.md#lint-a-custom-macro-like-a-built-in-macro\n\n; TODO use https://github.com/binaryage/cljs-devtools\n\n; Documentation\n; https://github.com/metosin/spec-tools/blob/master/docs/02_data_specs.md\n"]}